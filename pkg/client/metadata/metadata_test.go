//go:build unit

/*
 * @license
 * Copyright 2023 Dynatrace LLC
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package metadata

import (
	"errors"
	"fmt"
	"github.com/dynatrace/dynatrace-configuration-as-code/v2/internal/featureflags"
	"github.com/dynatrace/dynatrace-configuration-as-code/v2/pkg/rest"
	"github.com/stretchr/testify/require"
	"golang.org/x/net/context"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
)

type respFunc func(ctx context.Context, url string) (rest.Response, error)
type testClient struct {
	getResp respFunc
}

func (c *testClient) Get(ctx context.Context, url string) (rest.Response, error) {
	return c.getResp(ctx, url)
}

func TestGetDynatraceClassicURL(t *testing.T) {

	tests := []struct {
		name              string
		givenServerURL    string
		givenResponseFunc respFunc
		want              string
		wantErr           bool
	}{
		{
			name:           "client GET error results in error",
			givenServerURL: "https://id.env.com",
			givenResponseFunc: func(ctx context.Context, url string) (rest.Response, error) {
				return rest.Response{}, errors.New("err")
			},
			wantErr: true,
		},
		{
			name:              "server responds with code != 200 results in error",
			givenServerURL:    "id.env.com",
			givenResponseFunc: classicEnvDomainAPICall(http.StatusNotFound, ""),
			wantErr:           true,
		},
		{
			name:              "unauthorized response results in error",
			givenServerURL:    "id.env.com",
			givenResponseFunc: classicEnvDomainAPICall(http.StatusUnauthorized, ""),
			wantErr:           true,
		},
		{
			name:              "server response with invalid data",
			givenServerURL:    "https://id.env.com",
			givenResponseFunc: classicEnvDomainAPICall(http.StatusOK, "}"),
			wantErr:           true,
		},
		{
			name:              "server response with valid data",
			givenServerURL:    "https://id.env.com",
			givenResponseFunc: classicEnvDomainAPICall(http.StatusOK, `{"domain" : "https://classic.env.com"}`),
			want:              "https://classic.env.com",
		},
		{
			name:           "does not query for classic URL if URL can be built from base pattern",
			givenServerURL: "https://id.apps.env.com",
			givenResponseFunc: func(ctx context.Context, url string) (rest.Response, error) {
				if url != "https://id.live.env.com" {
					return rest.Response{}, fmt.Errorf("expected only calls to autogenerated classic URL but got call to %q", url)
				}
				return rest.Response{StatusCode: http.StatusOK}, nil
			},
			want: "https://id.live.env.com",
		},
		{
			name:           "queries for classic URL if built URL is invalid",
			givenServerURL: "https://id.apps.env.com",
			givenResponseFunc: func(ctx context.Context, url string) (rest.Response, error) {
				if url == "https://id.live.env.com" {
					return rest.Response{StatusCode: http.StatusNotFound}, nil
				}

				if url == "https://id.apps.env.com"+ClassicEnvironmentDomainPath {
					return rest.Response{
						StatusCode: http.StatusOK,
						Body:       []byte(`{"domain" : "https://classic.env.com"}`),
					}, nil
				}

				return rest.Response{}, fmt.Errorf("unexpected call to %q", url)
			},
			want: "https://classic.env.com",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {

			got, err := GetDynatraceClassicURL(context.TODO(), &testClient{getResp: tt.givenResponseFunc}, tt.givenServerURL)
			require.Equal(t, tt.want, got)
			require.Equal(t, tt.wantErr, err != nil)

		})
	}
}

func classicEnvDomainAPICall(serverResponseStatus int, serverResponse string) respFunc {
	return func(_ context.Context, url string) (rest.Response, error) {
		if strings.HasSuffix(url, ClassicEnvironmentDomainPath) {
			return rest.Response{
				StatusCode: serverResponseStatus,
				Body:       []byte(serverResponse),
			}, nil
		}

		return rest.Response{}, fmt.Errorf("expected only calls to autogenerated classic URL but got call to %q", url)
	}
}

func TestGetDynatraceClassicURL_DoesNotBuildSimpleURLIfFeatureFlagIsOff(t *testing.T) {
	t.Setenv(featureflags.Permanent[featureflags.BuildSimpleClassicURL].EnvName(), "false")

	platformURL := "https://id.apps.env.com"

	c := &testClient{
		getResp: func(ctx context.Context, url string) (rest.Response, error) {
			if url == "https://id.live.env.com" {
				t.Fatalf("unexpected call to validate auto-generated Classic URL - should not happen with %q flag off", featureflags.Permanent[featureflags.BuildSimpleClassicURL].EnvName())
			}

			if url == "https://id.apps.env.com"+ClassicEnvironmentDomainPath {
				return rest.Response{
					StatusCode: http.StatusOK,
					Body:       []byte(`{"domain" : "https://classic.env.com"}`),
				}, nil
			}

			t.Fatalf("unexpected call to %q", url)
			return rest.Response{}, nil
		},
	}

	got, err := GetDynatraceClassicURL(context.TODO(), c, platformURL)
	require.Equal(t, "https://classic.env.com", got)
	require.NoError(t, err)
}

func TestGetDynatraceClassicURL_WorksWithTrailingSlash(t *testing.T) {
	server := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
		if req.URL.Path == ClassicEnvironmentDomainPath {
			rw.WriteHeader(http.StatusOK)
			_, _ = rw.Write([]byte(`{"domain" : "http://classic.env.com"}`))
		} else {
			rw.WriteHeader(http.StatusNotFound)
		}
	}))
	defer server.Close()

	got, err := GetDynatraceClassicURL(context.TODO(), rest.NewRestClient(&http.Client{}, nil, rest.CreateRateLimitStrategy()), server.URL+"/")
	require.Equal(t, "http://classic.env.com", got)
	require.NoError(t, err)
}
